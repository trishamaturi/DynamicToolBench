{
    "product_id": "api_03f41120-c406-4667-812d-6547ebcefffa",
    "tool_description": "Translate API using the best translation engine.",
    "home_url": "https://rapidapi.com/datascraper/api/g-translate1/",
    "name": "G Translate",
    "title": "G Translate",
    "pricing": "FREEMIUM",
    "tool_name": "G Translate",
    "score": {
        "avgServiceLevel": 100,
        "avgLatency": 1875,
        "avgSuccessRate": 100,
        "popularityScore": 9.1,
        "__typename": "Score"
    },
    "host": "g-translate1.p.rapidapi.com",
    "api_list": [
        {
            "name": "Get Supported Languages",
            "url": "https://g-translate1.p.rapidapi.com/languages",
            "description": "Get Supported Languages",
            "method": "GET",
            "required_parameters": [],
            "optional_parameters": [],
            "code": "import requests\n\nurl = \"https://g-translate1.p.rapidapi.com/languages\"\n\nheaders = {\n            \"X-RapidAPI-Key\": \"SIGN-UP-FOR-KEY\",\n            \"X-RapidAPI-Host\": \"g-translate1.p.rapidapi.com\"\n        }\n\nresponse = requests.get(url, headers=headers)\nprint(response.json())\n",
            "convert_code": "import requests\n\nurl = \"https://g-translate1.p.rapidapi.com/languages\"\n\nheaders = {\n            \"X-RapidAPI-Key\": \"SIGN-UP-FOR-KEY\",\n            \"X-RapidAPI-Host\": \"g-translate1.p.rapidapi.com\"\n        }\n\nresponse = requests.get(url, headers=headers)\nprint(response.json())\n",
            "test_endpoint": "",
            "statuscode": 200,
            "schema": {}
        },
        {
            "name": "Translate Text",
            "url": "https://g-translate1.p.rapidapi.com/translate",
            "description": "Translate Text",
            "method": "GET",
            "required_parameters": [
                {
                    "name": "text",
                    "type": "STRING",
                    "description": "",
                    "default": "One idea behind Java's automatic memory management model is that programmers should be spared the burden of having to perform manual memory management. In some languages the programmer allocates memory to create any object stored on the heap and is responsible for later manually deallocating that memory to delete any such objects. If a programmer forgets to deallocate memory or writes code that fails to do so in a timely fashion, a memory leak can occur: the program will consume a potentially arbitrarily large amount of memory. In addition, if a region of memory is deallocated twice, the program can become unstable and may crash. Finally, in non garbage collected environments, there is a certain degree of overhead and complexity of user-code to track and finalize allocations."
                },
                {
                    "name": "tl",
                    "type": "STRING",
                    "description": "",
                    "default": "ru"
                }
            ],
            "optional_parameters": [
                {
                    "name": "sl",
                    "type": "STRING",
                    "description": "",
                    "default": "en"
                }
            ],
            "code": "import requests\n\nurl = \"https://g-translate1.p.rapidapi.com/translate\"\nquerystring = {\"text\": \"One idea behind Java's automatic memory management model is that programmers should be spared the burden of having to perform manual memory management. In some languages the programmer allocates memory to create any object stored on the heap and is responsible for later manually deallocating that memory to delete any such objects. If a programmer forgets to deallocate memory or writes code that fails to do so in a timely fashion, a memory leak can occur: the program will consume a potentially arbitrarily large amount of memory. In addition, if a region of memory is deallocated twice, the program can become unstable and may crash. Finally, in non garbage collected environments, there is a certain degree of overhead and complexity of user-code to track and finalize allocations.\", \"tl\": \"ru\", \"sl\": \"en\"}\n\nheaders = {\n            \"X-RapidAPI-Key\": \"SIGN-UP-FOR-KEY\",\n            \"X-RapidAPI-Host\": \"g-translate1.p.rapidapi.com\"\n        }\n\nresponse = requests.get(url, headers=headers, params=querystring)\nprint(response.json())\n",
            "convert_code": "import requests\n\nurl = \"https://g-translate1.p.rapidapi.com/translate\"\nquerystring = {\"text\": \"One idea behind Java's automatic memory management model is that programmers should be spared the burden of having to perform manual memory management. In some languages the programmer allocates memory to create any object stored on the heap and is responsible for later manually deallocating that memory to delete any such objects. If a programmer forgets to deallocate memory or writes code that fails to do so in a timely fashion, a memory leak can occur: the program will consume a potentially arbitrarily large amount of memory. In addition, if a region of memory is deallocated twice, the program can become unstable and may crash. Finally, in non garbage collected environments, there is a certain degree of overhead and complexity of user-code to track and finalize allocations.\", \"tl\": \"ru\", \"sl\": \"en\"}\n\nheaders = {\n            \"X-RapidAPI-Key\": \"SIGN-UP-FOR-KEY\",\n            \"X-RapidAPI-Host\": \"g-translate1.p.rapidapi.com\"\n        }\n\nresponse = requests.get(url, headers=headers, params=querystring)\nprint(response.json())\n",
            "test_endpoint": "",
            "statuscode": 200,
            "schema": {}
        }
    ]
}